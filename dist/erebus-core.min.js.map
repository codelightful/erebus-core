{"version":3,"file":"erebus-core.min.js","sources":["../src/events.mjs","../src/element.mjs","../src/erebus.mjs"],"sourcesContent":["/**\r\n * Allows to register a callback to be executed when the document ready state has been reached\r\n * @param callback Function to be executed when the document ready is reached\r\n */\r\n function onReady(callback) {\r\n\tif (document.readyState === 'complete') {\r\n\t\tcallback();\r\n\t} else if (typeof (document.addEventListener) === 'function') {\r\n\t\tdocument.addEventListener('DOMContentLoaded', callback, false);\r\n\t} else if (typeof (document.attachEvent) === 'function') {\r\n\t\tdocument.attachEvent('onreadystatechange', function () {\r\n\t\t\tif (document.readyState === 'complete') {\r\n\t\t\t\tcallback();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\nexport default { onReady };","/**\r\n * Parses a string HTML content and returns its content or null if it is not HTML content\r\n * @param {string} content HTML content to parse\r\n * @returns DOM elements representing the content\r\n */\r\nfunction parseHTML(content) {\r\n\tif (!content || typeof (content) !== 'string') {\r\n\t\treturn [];\r\n\t}\r\n\tconst holder = document.createElement('div');\r\n\tholder.innerHTML = content;\r\n\treturn [...holder.childNodes];\r\n}\r\n\r\n/**\r\n * Removes all the child nodes from a specific element\r\n * @param {HTMLElement} Element to remove the childs from it\r\n */\r\nfunction removeAllChild(element) {\r\n\tif (!element || !element instanceof HTMLElement) {\r\n\t\treturn;\r\n\t}\r\n\twhile (element.firstChild) {\r\n\t\telement.removeChild(element.firstChild);\r\n\t}\r\n}\r\n\r\n/**\r\n * Executes a deep copy of an HTMLElement\r\n * @param {HTMLElement} sourceElement Element to copy\r\n * @returns Copy of the element\r\n */\r\nfunction cloneHTMLElement(sourceElement) {\r\n\tif (!sourceElement || !sourceElement instanceof HTMLElement) {\r\n\t\treturn null;\r\n\t}\r\n\tconst clonedElement = sourceElement.cloneNode(true);\r\n\tif(clonedElement.nodeType === 1) {\r\n\t\tclonedElement.removeAttribute('id'); // the element identifier should not be cloned\r\n\t}\r\n\treturn clonedElement;\r\n}\r\n\r\n/**\r\n * Internal method to create an ErebusElement based on the data provided\r\n * @param {*} source String with the selector, string with HTML code (to create a wrapper for it), reference to an HTMLElement\r\n * @returns \r\n */\r\nfunction getElement(source) {\r\n\tif (!source) {\r\n\t\treturn null;\r\n\t} else if (source instanceof ErebusElement) {\r\n\t\treturn source;\r\n\t} else if (source instanceof HTMLElement) {\r\n\t\treturn new ErebusElement(source);\r\n\t} else if (typeof (source) === 'string') {\r\n\t\tvar nativeSource;\r\n\t\tif (source === 'body') {\r\n\t\t\tnativeSource = document.body;\r\n\t\t} else if (source.startsWith('<') && source.endsWith('>')) {\r\n\t\t\tnativeSource = parseHTML(source);\r\n\t\t} else if (source.startsWith('#')) {\r\n\t\t\tnativeSource = document.getElementById(source.substring(1));\r\n\t\t\tif (!nativeSource) {\r\n\t\t\t\tthrow Error('erebus.element.unknown_element_id[' + source + ']');\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tnativeSource = document.querySelectorAll(source);\r\n\t\t\tif (nativeSource.length === 0) {\r\n\t\t\t\tthrow Error('erebus.element.unknown_selector[' + source + ']');\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new ErebusElement(nativeSource);\r\n\t}\r\n}\r\n\r\n/** Wrapper to allow common methods to handle HTML content */\r\nclass ErebusElement {\r\n\t#wrappedElements;\r\n\t#hidden;\r\n\r\n\tconstructor(element) {\r\n\t\tthis.#hidden = false;\r\n\t\tif (element instanceof HTMLElement) {\r\n\t\t\tthis.#wrappedElements = [];\r\n\t\t\tthis.#wrappedElements.push(element);\r\n\t\t} else if (element instanceof NodeList) {\r\n\t\t\tthis.#wrappedElements = Array.from(element);\r\n\t\t} else if (Array.isArray(element)) {\r\n\t\t\tthis.#wrappedElements = element;\r\n\t\t} else {\r\n\t\t\tthrow Error('erebus.element.unknown_type[' + typeof (element) + ']');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates each wrapped element and invokes a handler that receives each separate instane\r\n\t * @param {function} handler Function that receives each separated HTMLElement wrapped, the function\r\n\t * \t\t\treceives the instance and an integer with the index of the element\r\n\t */\r\n\teach(handler) {\r\n\t\tfor (let wdx = 0; wdx < this.#wrappedElements.length; wdx++) {\r\n\t\t\tconst result = handler(this.#wrappedElements[wdx], wdx);\r\n\t\t\tif (result === false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the innerHTML on the wrapped elements\r\n\t */\r\n\tset innerHTML(value) {\r\n\t\tthis.each(element => {\r\n\t\t\telement.innerHTML = value;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the content inside the wrapped elements.  This method is preferred over innerHTML\r\n\t * since it cleans the event listener associated with the child nodes.\r\n\t * @param {*} value String with the content to add (text or HTML), a reference to a HTMLElement to set as the content\r\n\t * \t\t\tor a reference to another ErebusElement.\r\n\t * @returns The current wrapper instance\r\n\t */\r\n\tcontent(value) {\r\n\t\tthis.each((element, index) => {\r\n\t\t\tif (typeof (value) === 'string') {\r\n\t\t\t\telement.innerHTML = value;\r\n\t\t\t} else if (value instanceof HTMLElement) {\r\n\t\t\t\tremoveAllChild(element);\r\n\t\t\t\tif (index === 0) {\r\n\t\t\t\t\telement.appendChild(value);\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.appendChild(cloneHTMLElement(value));\r\n\t\t\t\t}\r\n\t\t\t} else if (value instanceof ErebusElement) {\r\n\t\t\t\tremoveAllChild(element);\r\n\t\t\t\tif (index === 0) {\r\n\t\t\t\t\tvalue.setParentNode(element);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalue.clone().setParentNode(element);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Append the current instance to a specific parent\r\n\t * @param {*} parent String with the parent selector, reference to the HTMLElement to use as a parent or\r\n\t * \t\t\treference to an ErebusElement or null to detach the wrapped elements\r\n\t * @returns The current wrapper instance\r\n\t */\r\n\tsetParentNode(parent) {\r\n\t\tif (!parent) {\r\n\t\t\tthis.each(element => {\r\n\t\t\t\telement.parentNode.removeChild(element);\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t} else if (typeof (parent) === 'string') {\r\n\t\t\tparent = getElement(parent);\r\n\t\t} else if (typeof (parent.appendChild) !== 'function') {\r\n\t\t\tthrow Error('erebus.wrapper.append_to.invalid_parent[' + typeof (parent) + ']');\r\n\t\t}\r\n\t\tthis.each(element => {\r\n\t\t\tparent.appendChild(element);\r\n\t\t});\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Alias to the setParent node method that allows to enable compatibility with DOM elements */\r\n\tset parentNode(parent) {\r\n\t\tthis.setParentNode(parent);\r\n\t}\r\n\r\n\t/**\r\n\t * Append a child element to the wrapped element\r\n\t * @param {*} value String with the HTML element to add or reference to the HTML element to add or \r\n\t * \t\t\treference to the ErebusElement to add.\r\n\t * @returns \r\n\t */\r\n\tappendChild(value) {\r\n\t\tif (typeof (value) === 'string') {\r\n\t\t\tconst parsedContent = parseHTML(value);\r\n\t\t\tthis.each((element, index) => {\r\n\t\t\t\tfor (let idx = 0; idx < parsedContent.length; idx++) {\r\n\t\t\t\t\tconst content = parsedContent[idx];\r\n\t\t\t\t\tif (index === 0) {\r\n\t\t\t\t\t\telement.appendChild(content);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telement.appendChild(cloneHTMLElement(content));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tthis.each((element, index) => {\r\n\t\t\t\tif (value instanceof HTMLElement) {\r\n\t\t\t\t\tif (index === 0) {\r\n\t\t\t\t\t\telement.appendChild(value);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\telement.appendChild(cloneHTMLElement(value));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (value instanceof ErebusElement) {\r\n\t\t\t\t\tvalue.each(innerElement => {\r\n\t\t\t\t\t\tif (index === 0) {\r\n\t\t\t\t\t\t\telement.appendChild(innerElement);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\telement.appendChild(cloneHTMLElement(innerElement));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Adds a listener to the current instance and its wrapped elements */\r\n\taddEventListener(eventName, listener) {\r\n\t\tif(!eventName) {\r\n\t\t\tthrow Error('erebus.element.add_listener.null_event_name');\r\n\t\t} else if(typeof(listener) === 'function') {\r\n\t\t\tthis.each(element => {\r\n\t\t\t\tif (typeof (element.addEventListener) === 'function') {\r\n\t\t\t\t\telement.addEventListener(eventName, listener, false);\r\n\t\t\t\t} else if (typeof (element.attachEvent) === 'function') {\r\n\t\t\t\t\telement.attachEvent('on' + eventName, listener);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/** Allows to determine if the element is hidden or not */\r\n\tget isHidden() {\r\n\t\treturn this.#hidden;\r\n\t}\r\n\r\n\t/** Hides the wrapped elements to make it invisible */\r\n\thide() {\r\n\t\tif(this.#hidden) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.#hidden = true;\r\n\t\tthis.each(element => {\r\n\t\t\tconst computedDisplay = getComputedStyle(element).getPropertyValue('display');\r\n\t\t\tif(computedDisplay && computedDisplay !== 'none') {\r\n\t\t\t\telement.originalDisplay = computedDisplay;\r\n\t\t\t}\r\n\t\t\telement.style.display = 'none';\r\n\t\t});\r\n\t}\r\n\r\n\t/** Shows the wrapped elements to make it visible */\r\n\tshow() {\r\n\t\tthis.each(element => {\r\n\t\t\tconst computedDisplay = getComputedStyle(element).getPropertyValue('display');\r\n\t\t\tif(computedDisplay && computedDisplay === 'none') {\r\n\t\t\t\tif(element.originalDisplay) {\r\n\t\t\t\t\telement.style.display = element.originalDisplay;\r\n\t\t\t\t\tdelete element.originalDisplay;\r\n\t\t\t\t} else {\r\n\t\t\t\t\telement.style.display = 'block';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/** Clone the current instance */\r\n\tclone() {\r\n\t\tconst clonedWrapped = [];\r\n\t\tthis.each(element => {\r\n\t\t\tclonedWrapped.push(cloneHTMLElement(element));\r\n\t\t});\r\n\t\treturn new ErebusElement(clonedWrapped);\r\n\t}\r\n}\r\n\r\nexport default getElement;","'use strict';\r\nimport events from './events.mjs';\r\nimport element from './element.mjs';\r\n\r\nexport default { events, element };\r\n"],"names":["onReady","callback","document","readyState","addEventListener","attachEvent","parseHTML","content","holder","createElement","innerHTML","childNodes","removeAllChild","element","HTMLElement","firstChild","removeChild","cloneHTMLElement","sourceElement","clonedElement","cloneNode","nodeType","removeAttribute","getElement","source","ErebusElement","nativeSource","body","startsWith","endsWith","getElementById","substring","Error","querySelectorAll","length","constructor","hidden","wrappedElements","push","NodeList","Array","from","isArray","each","handler","wdx","this","value","index","appendChild","setParentNode","clone","parent","parentNode","parsedContent","idx","innerElement","eventName","listener","isHidden","hide","computedDisplay","getComputedStyle","getPropertyValue","originalDisplay","style","display","show","clonedWrapped","events"],"mappings":"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"}